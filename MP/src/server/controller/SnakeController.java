package server.controller;

import server.exceptons.AutoHitException;
import server.model.Node;
import server.model.ScoreCounter;
import server.model.Snake;

import java.io.*;
import java.net.Socket;
import java.util.Observable;
import java.util.Observer;
import java.util.Random;

/**
 * Controller of the snake on the server side, is also the observer for the snake and the scorecounter
 * s:socket accepted on the class ServerConnection, used to connect with the client
 * iST: inputStream used to receive information from the socket
 * oST: outputStream used to send information to the socket
 * read: reader used to read information of the inputStream as String
 * writer: writer used to write information to the outputstream as a String
 * snk: instance of the Snake this class contains the logic of the game
 * treasure: node used to represent the treasure
 * connected: boolean that represents the state of the controller, if its not connected, its execution stops
 * stopped: boolean used to pause the game
 */
public class SnakeController extends Thread implements Observer {

    private final int MAX_SIZE = 90;

    private Socket s;
    private InputStream iST;
    private OutputStream oST;
    BufferedReader read;
    PrintWriter writer;

    private Snake snk;
    private Node treasure;

    private boolean connected;

    private boolean stopped;

    /**
     *  initializes all the fields declared previously
     * @param s socket accepted by the server connection
     * @param inputStream inputStream generated by the socket
     * @param outputStream outputStream generated by the socket
     * @param id id for the controller
     * @param scores score counter instance, which is common to all snake controllers instanced
     */
    public SnakeController(Socket s, InputStream inputStream, OutputStream outputStream,int id, ScoreCounter scores) {

        this.s = s;
        this.iST = inputStream;
        this.oST = outputStream;
        this.snk = new Snake(scores,id);
        this.read = new BufferedReader(new InputStreamReader(iST));
        this.connected = true;
        this.stopped = true;
        this.snk.addObserver(this);
        scores.addObserver(this);
        this.treasure = new Node(0,0);

        this.writer = new PrintWriter(this.oST,true);

    }

    /**
     * method that generates a random treasure
     */
    public void randomTreasure(){
        Random rng = new Random();
        int x = rng.nextInt(MAX_SIZE-0);
        int y = rng.nextInt(MAX_SIZE-0);
        this.treasure.setPos(x,y);

            writer.println(("TRS;" + this.treasure.getX() + ";" + this.treasure.getY()));


    }

    /**
     * method that executes the logic of the game, moves the snake, and checks the possitions
     */
    public void run() {

        /**
         * loop used to initialize the game, name of the player, and first move, if no move is received, the game does not start
         */
        while (stopped) {
            try {
                String[] start = read.readLine().split(";");
                if (start[0].equals("STARTINFO")) {
                    this.snk.setName(start[2]);

                }if (start[0].equals("DIR")) {
                    this.snk.setMov(start[1]);
                    this.stopped = false;
                }
                this.randomTreasure();

            } catch (IOException e) {
                this.connected= false;
                this.stopped= false;
                e.printStackTrace();
            }
        }


        /**
         * loop executed while the client is connected to this controller, it parses the messages received and updates the scorecounter and the snake
         *
         */
        while (this.connected) {


            try {
                if (this.iST.available()>0) {                                                                           //if the inputStream does not contain data, the snake keeps moving
                    String[] msg = read.readLine().split(";");
                    if (msg[0].equals("FIN")) {                                                                         //checks if the client wants to disconnect
                        this.snk.delete();
                        this.s.close();
                        this.connected = false;
                        this.stopped=true;

                        this.finalize();
                        return;
                    } else {
                        switch (msg[0]) {
                            case "DIR":                                                                                 //changes the direction of the snake
                                this.snk.setMov(msg[1]);

                                break;

                            case "STP":                                                                                 //pauses the game

                                this.stopped = true;

                                while (this.stopped) {
                                    msg = read.readLine().split(";");
                                    if (msg[0].equals("START")) {
                                        this.stopped = false;
                                    }
                                }
                                break;

                            case "START":

                                this.stopped = false;
                                break;


                            default:
                                System.out.println("No message received");

                        }

                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (Throwable throwable) {
                throwable.printStackTrace();
            }

            try{
            if (this.checkTreasure()) {                                                                                 //checks if the snake got the treasure
                snk.addScore();                                                                                         // if so, score is added, and the last pos is not polled so the snake grows
                snk.move("keep");
                this.randomTreasure();

            } else {
                snk.move("poll");                                                                                //if not, the las possition is polled, and deleted

            }}catch (AutoHitException e){                                                                               //if the snake hits itself, this exception is throwed, this means end of the game
                this.connected = false;
                this.stopped = true;
                this.writer.println(e.getMessage());

            }

            try {
                sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * method that checks if the snake got the treasure
     * @return
     */
    private boolean checkTreasure() {
        return snk.getTail().equals(this.treasure);
    }

    /**
     * method called when any observable linked to this controller is modified, it sends a message to the client
     * @param o
     * @param arg
     */
    @Override
    public void update(Observable o, Object arg) {
        String msg = o.toString();

            writer.println(msg);


    }
}
